<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="matthew-sword&#39;s blog">
    

    <!--Author-->
    
        <meta name="author" content="matthew-sword">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Record&amp;Think"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="matthew-sword&#39;s blog" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Record&amp;Think"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>Record&amp;Think</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    主页
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    归档
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    关于
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    标签
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    分类
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    联系我
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">Record&Think</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/12/15/关于系统底层/关于系统底层/">
                关于系统底层的杂烩
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-12-15</span>
            
            
            
                <span class="category">
                    <a href="/categories/sundry/">sundry</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="关于系统底层的杂烩"><a href="#关于系统底层的杂烩" class="headerlink" title="关于系统底层的杂烩"></a>关于系统底层的杂烩</h1><h2 id="操作系统启动过程（-）"><a href="#操作系统启动过程（-）" class="headerlink" title="操作系统启动过程（##）"></a>操作系统启动过程（##）</h2><h3 id="1、通电后从主板ROM上读取BIOS，进行系统硬件自检"><a href="#1、通电后从主板ROM上读取BIOS，进行系统硬件自检" class="headerlink" title="1、通电后从主板ROM上读取BIOS，进行系统硬件自检"></a>1、通电后从主板ROM上读取BIOS，进行系统硬件自检</h3><ul>
<li>BIOS烧录在主板的ROM上</li>
<li>硬件自检若出现故障，电脑会发出蜂鸣声</li>
</ul>
<p>###2、依照启动顺序将电脑控制权交给下一阶段启动程序</p>
<ul>
<li>依照Boot Priority Order的顺序将控制权给下一个外部存储设备</li>
</ul>
<h3 id="3、读取主引导记录（MBR）"><a href="#3、读取主引导记录（MBR）" class="headerlink" title="3、读取主引导记录（MBR）"></a>3、读取主引导记录（MBR）</h3><ul>
<li><p>计算机读取该设备的第一个扇区（前512字节）</p>
<p><strong>主引导记录结构</strong></p>
<ul>
<li><p>1-446字节：调用操作系统的机器码</p>
</li>
<li><p>447-510字节：分区表</p>
</li>
<li><p>511-512字节：主引导签名记录（0x550xAA），表明该设备适用于启动的</p>
</li>
</ul>
<p><strong>分区表结构</strong>，分区表一共64字节，分成四个<strong>主分区</strong>，每一项（16字节）组成如下</p>
<ul>
<li><p>1字节：0x80表示该主分区为<strong>激活分区</strong>，控制权要交给它，四个主分区里面只能有<strong>一个是激活</strong>的。</p>
</li>
<li><p>2-4字节：主分区第一个扇区所在物理位置（柱面、磁头、扇区号）</p>
</li>
<li><p>5字节：主分区类型</p>
</li>
<li><p>6-8字节：主分区最后一个扇区的物理位置</p>
</li>
<li><p>9-12字节：主分区第一个扇区的逻辑地址</p>
</li>
<li><p>13-16字节：主分区的扇区总数</p>
<p>扇区总数决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。</p>
</li>
</ul>
</li>
</ul>
<h3 id="4、硬盘启动"><a href="#4、硬盘启动" class="headerlink" title="4、硬盘启动"></a>4、硬盘启动</h3><ul>
<li><p>计算机的控制权交到存储设备（一般为硬盘）的某个分区</p>
<p><strong>此处分为3种情况</strong></p>
<ul>
<li><p>卷引导记录</p>
<p>计算机会读取激活分区的第一个扇区，叫做卷引导记录（VBR）。卷引导记录存有操作系统在这个分区里的位置</p>
</li>
<li><p>扩展分区和逻辑分区</p>
<p>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定<strong>有且仅有一个</strong>区可以被定义成”扩展分区”（Extended partition）。所谓”扩展分区”，就是指这个区里面又分成多个区。这种<strong>分区里面的分区</strong>，就叫做”逻辑分区”（logical partition）。<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="external">具体过程看此处</a></p>
<p>似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。</p>
<p>​</p>
</li>
<li><p>启动管理器</p>
<p>在这种情况下，计算机读取”主引导记录”前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统。比如 grub</p>
<h3 id="5、操作系统"><a href="#5、操作系统" class="headerlink" title="5、操作系统"></a>5、操作系统</h3></li>
</ul>
</li>
<li><p>控制权转交给操作系统后，操作系统的内核首先被载入内存。</p>
</li>
</ul>
<p>​             以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。</p>
<p>​                                                                                                       参考自<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="external">阮一峰的网络日志</a></p>
<h2 id="机械硬盘结构"><a href="#机械硬盘结构" class="headerlink" title="机械硬盘结构"></a>机械硬盘结构</h2><p><img src="hdd.jpg" alt="hdd"></p>
<p>机械硬盘主要由以下几部分组成：机械手臂（Boom）,磁头（Head）,转轴（Spindle），盘片（Platter）组成，在实际应用中又将盘片分成了磁道（Track），扇区（Sector）和柱面（Cylinder）。每一个盘片的结构如图</p>
<p><img src="plater.png" alt="plater"></p>
<h3 id="磁道"><a href="#磁道" class="headerlink" title="磁道"></a>磁道</h3><p>​         每个盘片的每个盘面被划分成多个狭窄的同心圆环，数据就是存储在这样的同心圆环上，我们将这样的圆环称为磁道(Track)，每个盘面可以划分多个磁道。在每个盘面的最外圈，离盘心最远的地方是“0”磁道，向盘心方向依次增长为1磁道，2磁道，等等。硬盘数据的存放就是从最外圈开始。</p>
<h3 id="扇区"><a href="#扇区" class="headerlink" title="扇区"></a>扇区</h3><p>每个磁道划分成若干弧段，每段称为一个扇区(Sector)。扇区是硬盘上存储的物理单位。从DOS时代起，每扇区是128×22＝512字节，现在已经成了业界不成文的规定。另外扇区的编号是从1开始，而不是0。</p>
<h3 id="柱面"><a href="#柱面" class="headerlink" title="柱面"></a>柱面</h3><p>柱面是抽象出来的一个逻辑概念，前面说过，离盘心最远的磁道为0磁道，依此往里为1磁道，2磁道，3磁道….，不同面上相同磁道编号则组成了一个圆柱面，即所称的柱面(Cylinder)。</p>
<h3 id="簇"><a href="#簇" class="headerlink" title="簇"></a>簇</h3><p>物理相邻的若干个扇区称为簇。<strong>操作系统读写磁盘的基本单位是扇区，而文件系统的基本单位是簇(Cluster)</strong>。在Windows下，随便找个几字节的文件，在其上面点击鼠标右键选择属性，看看实际大小与占用空间两项内容，如大小：15 字节 (15 字节)， 占用空间：4.00 KB (4，096 字节)。这里的占用空间就是你机器分区的簇大小，因为<strong>再小的文件都会占用空间，逻辑基本单位是4K</strong>，所以都会占用4K。 簇一般有这几类大小 4K，8K，16K，32K，64K等。簇越大存储性能越好，但空间浪费严重。簇越小性能相对越低，但空间利用率高。NTFS格式的文件系统簇的大小为4K。</p>
<p>​                                                                                                                        参考自<a href="http://blog.csdn.net/xingjiarong/article/details/46312571" target="_blank" rel="external">csdn博客</a></p>
<h2 id="MBR和GPT"><a href="#MBR和GPT" class="headerlink" title="MBR和GPT"></a>MBR和GPT</h2><p>由于磁盘容量越来越大，传统的MBR分区表（主引导记录）已经不能满足大容量磁盘的需求。传统的MBR分区表只能识别磁盘前面的2.2TB左右的空间，对于后面的多余空间只能浪费掉了，而对于单盘4TB的磁盘，只能利用一半的容量。因此，才有了GPT（全局唯一标识分区表）。</p>
<h3 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h3><p>GPT：<strong>GUID Partition Table</strong></p>
<p>GTP分区格式则较为新颖，也是为了逐渐取代MBR而生。谈到GTP分区，就不得不说到UEFI(是什么的缩写？)，UEFI也是为了取代历史悠久的BIOS而出现的。GUID分区表格式，之所以被称作UEFI，是因为<strong>该分区格式为硬盘上的每一个分区都分配了“唯一”的数据标识符，或者称作”GUID”</strong>，意为一个随机长度的字符串，这样的随机性和长度组合，<strong>基本可以保障世界上每一个GPT的分区都不会相同</strong>。GPT分区没有MBR分区的限制，比如GPT的分区可以超越2TB的容量限制，并且分区的个数没有数量上限。而此时唯一的限制，就是操作系统对GPT分区的限制，比如，在WINDOWS系统条件下，GPT划分最多的分区数量为128，但是相应的，GPT分区也不再需要像MBR分区那样，为了多个分区而必须建立扩展分区。</p>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>GPT分区通常为了保持对MBR分区的兼容性，从而包含一份所谓的”保护性MBR分区表“，这意味着如果你使用老版本的磁盘工具读取GPT分区，那么工具通常会将GPT分区视为一整块都是扩展分区的MBR硬盘。这一兼容机制是为了保证老版本的磁盘工具不会将GPT分区视为未分区磁盘，从而错误的为GPT重新进行MBR分区操作，而破坏原有数据。</p>
<p>​                                                                                                                       参考自<a href="http://www.wuliaole.com/post/difference_between_GPT_and_MBR/" target="_blank" rel="external">无聊小博</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/12/09/HttpNote/">
                HttpStudy
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-12-09</span>
            
            
            
                <span class="category">
                    <a href="/categories/web/">web</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>#tinyhttpd学习</p>
<ul>
<li>由客户端程序和服务器程序构成，服务器程序由web服务器实现</li>
</ul>
<h2 id="相关文件函数"><a href="#相关文件函数" class="headerlink" title="相关文件函数"></a>相关文件函数</h2><h3 id="sys-socket-h"><a href="#sys-socket-h" class="headerlink" title="sys/socket.h"></a>sys/socket.h</h3><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，<strong>它是一组接口</strong>。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<p><img src="D:\BLOG\source\_drafts\http协议\socket原理.PNG" alt="socket原理"></p>
<p>###struct sockaddr结构体</p>
<p>struct sockaddr和struct sockaddr_in这两个结构体用来处理网络通信的地址。</p>
<p>在各种系统调用或者函数中，只要和网络地址打交道，就得用到这两个结构体。</p>
<p>网络中的地址包含3个方面的属性：</p>
<p>1 地址类型: ipv4还是ipv6</p>
<p>2 ip地址</p>
<p>3 端口</p>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>    sa_family; <span class="comment">//通信类型，最常用的是"AF_INET"</span></div><div class="line">    <span class="keyword">char</span>              sa_data[<span class="number">14</span>]; <span class="comment">// 目标地址 和 端口信息</span></div><div class="line">                &#125;;</div><div class="line"><span class="comment">//sockaddr缺陷：将ip和端口号放到一起</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></div><div class="line">    <span class="keyword">short</span> sin_family;       <span class="comment">// 通信类型 e.g. AF_INET,AF_INET6</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  sin_port;    <span class="comment">// 端口号 e.g.htons(3490)</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>     <span class="comment">//ip地址</span></div><div class="line">    <span class="keyword">char</span> sin_zero[<span class="number">8</span>];     <span class="comment">// 8 bytes zero this if you want to</span></div><div class="line">                    &#125;;</div><div class="line"></div><div class="line"><span class="comment">//ip地址结构体  多余结构体？</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s_addr;</div><div class="line">               &#125;;</div></pre></td></tr></table></figure>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket( )"></a>socket( )</h3><p>​      socket()函数的原型如下，这个函数建立一个协议族为domain、协议类型为type、协议编号为protocol的<strong>套接字文件描述符</strong>。如果函数调用成功，会返回一个标识这个套接字的文件描述符，失败的时候返回-1。socket函数是任何套接口网络编程中第一个使用的函数，它向用户提供一个套接字，即套接口描述文件字，它是一个整数，如同文件描述符一样，是<strong>内核标识一个IO结构的索引</strong>(UID?)。通过socket函数，我们指定一个套接口的协议相关的属性，为进行使用socket api做好准备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li><p>domain用于设置网络通信的域，函数socket()根据这个参数选择通信协议的族。通信协议族在文件sys/socket.h中定义。</p>
</li>
<li><p>type用于设置套接字通信的类型，主要有SOCKET_STREAM（流式套接字）、SOCK——DGRAM（数据包套接字）等</p>
</li>
<li><p>protocol用于制定某个协议的特定类型，即type类型中的某个类型。通常某协议中只有一种特定类型，这样protocol参数仅能设置为0；但是有些协议有多种特定的类型，就需要设置这个参数来选择特定的类型</p>
</li>
<li><p><a href="http://blog.csdn.net/xc_tsao/article/details/44123331" target="_blank" rel="external">具体见此处</a>…</p>
</li>
</ul>
<h3 id="htonl"><a href="#htonl" class="headerlink" title="htonl( )"></a>htonl( )</h3><p>​         htonl把本机字节顺序转化为网络字节顺序，网络字节顺序（大尾顺序）就是指一个数在内存中存储的时候“高对低，低对高”（即一个数的高位字节存放于低地址单元，低位字节存放在高地址单元中）。但是计算机的内存存储数据时有可能是大尾顺序或者小尾顺序。</p>
<p>###bind( ) </p>
<p>​        在建立套接字文件描述符成功后，需要对套接字进行地址和端口的绑定，才能进行数据的接收和发送操作。</p>
<p>函数原型:<br><code>int bind(int sockfd, struct sockaddr * my_addr, int addrlen);</code></p>
<ul>
<li>sockfd: socket file descriptor 套接字文件描述符</li>
<li>struct sockaddr:网络通信的地址 ，协议类型，ip，端口</li>
<li>成功则返回0, 失败返回-1, 错误原因存于errno 中</li>
</ul>
<h3 id="getsockname"><a href="#getsockname" class="headerlink" title="getsockname( )"></a>getsockname( )</h3><p>​         用getsockname获得一个与socket相关的地址，服务器端可以通过它得到相关客户端地址，而客户端也可以得到当前已连接成功的socket的ip和端口。可用于验证某个socket是否存在。<br><a href="https://baike.baidu.com/item/getsockname(" target="_blank" rel="external">具体见此处</a>/10081920)</p>
<h3 id="listen"><a href="#listen" class="headerlink" title="listen ( )"></a>listen ( )</h3><p>listen函数使用主动连接套接口变为被连接套接口，使得一个进程可以接受其它进程的请求，从而成为一个服务器进程。在TCP服务器编程中listen函数把进程变为一个服务器，并指定相应的套接字变为被动连接。</p>
<p>函数原型：<code>int listen(int sockfd, int backlog);</code></p>
<ul>
<li><p>sockfd：socket file descriptor 套接字文件描述符</p>
<p>​        在被socket函数返回的套接字sockfd之时，它是一个<strong>主动连接的套接字</strong>，也就是此时系统假设用户会对这个套接字调用connect函数，期待它主动与其它进程连接，然后在服务 器编程中，用户希望这个套接字可以接受外来的连接请求，也就是被动等待用户来连接。由于系统默认时认为一个套接字是主动连接的，所以需要通过某种方式来告 诉系统，用户进程通过系统调用listen来完成这件事。</p>
</li>
<li><p>backlog：连接请求队列(queue of pending connections)的最大长度</p>
<p>​        在进程正理一个一个连接请求的时候，可能还存在其它的连接请求。因为TCP连接是一个过程，所以可能存在一种半连接的状态，有时由 于同时尝试连接的用户过多，使得服务器进程无法快速地完成连接请求。如果这个情况出现了，服务器进程希望内核如何处理呢？<strong>内核会在自己的进程空间里维护一 个队列以跟踪这些完成的连接</strong>，但服务器进程还没有接手处理或正在进行的连接，这样的一个队列内核不可能让其任意大，所以必须有一个大小的上限。这个 backlog告诉内核使用这个数值作为上限。</p>
</li>
<li><p><strong>listen函数一般在调用bind之后、调用accept之前调用</strong></p>
<h3 id="accept"><a href="#accept" class="headerlink" title="accept ( )"></a>accept ( )</h3></li>
</ul>
<p>​     当套接字处于监听（listen）状态时，可以通过 accept() 函数来接收客户端请求。accept() 返回一个新的套接字来和客户端通信，addr 保存了<strong>客户端的IP地址和端口号</strong>，而 sock 是服务器端的套接字，</p>
<p>函数原型：<br><code>int accept(int sever_sock, struct sockaddr *addr, socklen_t *addrlen);</code></p>
<ul>
<li><p>输入 sever_sock</p>
</li>
<li><p>返回client_sockfd</p>
</li>
<li><p>struct sockaddr: 客户端ip和端口</p>
</li>
</ul>
<p>###pthread</p>
<p>​        pthread定义了创建和操纵线程的一套API。具体Pthreads定义了一套C语言的类型、函数与常量，它以<code>pthread.h</code>头文件和一个线程库实现。Pthreads API中大致共有100个函数调用，全都以”pthread_”开头，并可以分为四类：</p>
<ul>
<li>线程管理，例如创建线程，等待(join)线程，查询线程状态等。</li>
<li>互斥锁（Mutex）：创建、摧毁、锁定、解锁、设置属性等操作</li>
<li>条件变量（Condition Variable）：创建、摧毁、等待、通知、设置与查询属性等操作</li>
<li>使用了互斥锁的线程间的同步管理</li>
</ul>
<p>####pthread_create( )</p>
<p>创建线程，若成功则返回0，否则返回出错编号</p>
<p>函数原型：<br><code>int pthread_create(pthread_t*restrict tidp,const pthread_attr_t *restrict_attr,void*（*start_rtn)(void*),void *restrict arg);</code></p>
<ul>
<li><p>tidp：线程ID，指向线程标识符的指针</p>
</li>
<li><p>restrict_attr：线程属性</p>
</li>
<li><p>(*start_rtn)(void*)：线程运行函数的起始地址(函数名是函数的入口的指针)</p>
</li>
<li><p>arg：运行函数的参数</p>
</li>
<li><p>e.g.: <code>pthread_create(&amp;newthread , NULL, accept_request, client_sock)</code></p>
<p>​</p>
</li>
</ul>
<p>###HTTP报文</p>
<p>请求</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /webDemo/Hellow HTTP/1.1  //请求行</div><div class="line">Host: localhost:8080      //请求头</div><div class="line">Connection: keep-alive</div><div class="line">Accept: text/html</div><div class="line">Accept-Encoding: gzip, deflate, sdch, br</div><div class="line">Accept-Language: zh-CN,zh;q=0.8</div><div class="line">                //空行，表示请求头已经结束</div><div class="line">data                //实体内容，GET方法此项为空。POST方法为提交的数据</div></pre></td></tr></table></figure>
<p>响应</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK       //响应行</div><div class="line">Server: Apache-Coyote/1.1  //相应头</div><div class="line">Content-Length: 0</div><div class="line">Date: Thu, 18 May 2017 13:21:23 GMT</div><div class="line">              //空行，表示响应头已经结束</div><div class="line">data              //实体内容</div></pre></td></tr></table></figure>
<h3 id="recv"><a href="#recv" class="headerlink" title="recv ( )"></a>recv ( )</h3><p>函数原型：<code>int recv( SOCKET s, char *buf, int  len, int flags)</code></p>
<ul>
<li><p>s: 接收端套接字描述符</p>
</li>
<li><p>*buf：缓冲区，用来存放recv函数接收到的数据</p>
</li>
<li><p>len：指明buf的长度</p>
</li>
<li><p>flags ：flags取值有：</p>
<ul>
<li>0：常规操作，与read()相同</li>
<li>MSG_DONTWAIT:将单个I／O操作设置为非阻塞模式</li>
<li>MSG_OOB:指明发送的是带外信息</li>
<li>MSG_PEEK:可以查看可读的信息，在接收数据后不会将这些数据丢失</li>
<li>MSG_WAITALL:通知内核直到读到请求的数据字节数时，才返回。</li>
</ul>
</li>
<li><p>成功执行时，返回接收到的字节数。</p>
</li>
<li><p>另一端已关闭则返回0</p>
</li>
<li><p>失败返回-1</p>
</li>
</ul>
<p>###send ( )</p>
<p>函数原型：<code>int send(int s, const void *msg, size_t len, int flags);</code></p>
<ul>
<li><p>s: 接收端套接字描述符</p>
</li>
<li><p>*buf：缓冲区，用来存放send函数接收到的数据</p>
</li>
<li><p>len：指明buf的长度</p>
</li>
<li><p>flags ：flags取值有：</p>
<ul>
<li><p>0： 与write()无异</p>
</li>
<li><p>MSG_DONTROUTE:告诉内核，目标主机在本地网络，不用查路由表</p>
</li>
<li><p>MSG_DONTWAIT:将单个I／O操作设置为非阻塞模式</p>
</li>
<li><p>MSG_OOB:指明发送的是带外信息</p>
</li>
</ul>
</li>
</ul>
<p>###CGI</p>
<p>CGI(Common Gateway Interface)是一个用于定Web服务器与外部程序之间通信方式的标准，其程序须运行在网络服务器上</p>
<h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><p>GET方法是默认的HTTP请求方法，用GET方法提交的数据将作为URL的一部分向Web服务器发送。?之后的内容为参数，不同参数之间用&amp;隔开 。（php获取get参数？）<br>例如：<br><a href="http://news.baidu.com/ns?word=akg&amp;tn=news&amp;from=news&amp;cl=2&amp;rn=20&amp;ct=1" target="_blank" rel="external">http://news.baidu.com/ns?word=akg&amp;tn=news&amp;from=news&amp;cl=2&amp;rn=20&amp;ct=1</a></p>
<p>###stat()</p>
<p>定义： int stat(const char <em>file_name, struct stat </em>buf); </p>
<p>通过文件名filename获取文件信息，并保存在buf所指的结构体stat中 。执行成功则返回0，失败返回-1，错误代码存于errno（需要include \<errno.h>）</errno.h></p>
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><ul>
<li><p>starup：在相应端口启动httpd服务</p>
<ul>
<li><p>用socket(int domain, int type, int protocol) 指定一个套接口的协议相关的属性，为进行使用socket api做好准备</p>
</li>
<li><p>用struct sockaddr指定网络通信地址</p>
</li>
<li><p>用bind()将socket套接字和一个IP地址及端口绑定</p>
</li>
<li><p>如果端口是 0，随机分配一个端口 。</p>
</li>
<li><p>用listen( )进行监听</p>
</li>
<li><p>返回<strong>套接字描述符</strong> （socket file descriptor）给主函数</p>
<p>​</p>
</li>
</ul>
</li>
<li><p>while( 1 )</p>
<ul>
<li><p><code>client_sock = accept( int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code><br>不断从已完成的服务端连接队列返回下一个已完成连接</p>
</li>
<li><p><code>pthread_create(&amp;newthread , NULL, accept_request, client_sock)</code></p>
<p> 用pthread_creat( )派生新线程，用accept_request( )处理新请求</p>
<p> <strong>accept_request(client_sockfd )</strong></p>
<ul>
<li><p><code>numchars = get_line( );//得到请求的第一行</code></p>
</li>
<li><p>方法不是GET或者POST， 则用unimplemented( )返回错误信息（http请求方法？？）    </p>
<ul>
<li>unimplemented( )发送http 错误代码 501，返回http相应报文</li>
</ul>
</li>
<li><p>若为POST方法则启用CGI</p>
</li>
<li><p>用get_line( )获取url，若有？开启CGI</p>
</li>
<li><p>根据url生成资源路径path</p>
</li>
<li><p>用stat()获取路径path对应文件(夹)信息</p>
</li>
<li><p>如果路径是目录则返回该目录下的index.html</p>
</li>
<li><p>如果是文件，先判断文件是否为cgi文件（是否有可执行权限）</p>
</li>
<li><p>若是cgi，则用execute_cgi( )执行该cgi</p>
<p><strong>execute_cgi( )</strong></p>
<ul>
<li>若method是GET，则完全丢弃请求头部</li>
<li>若method是POST，则找出：Content-Length</li>
<li>Content-Length没有找到，用bad_request( )返回 400 bad request</li>
<li>否则 返回 200，开始执行cgi</li>
<li>…….待续</li>
</ul>
<p>​</p>
</li>
<li><p>如果不是cgi，则返用serve_file( )回该文件</p>
</li>
<li><p>若没有找到相应文件或者目录，则用not_found()返回404 not fount</p>
</li>
<li><p>关闭http连接</p>
</li>
</ul>
</li>
</ul>
</li>
<li>结束服务</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/12/08/reg_exp待续/">
                reg_exp
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-12-08</span>
            
            
            
                <span class="category">
                    <a href="/categories/reg-exp/">reg_exp</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h1><ul>
<li>普通字符</li>
<li>转义字符</li>
<li>特殊字符（使用其本身需要转义）<ul>
<li>$ 匹配末尾</li>
<li>() 表示一个子表达式</li>
<li>* 匹配前面子表达式0或多次</li>
<li>+ 匹配前面子表达式0或多次</li>
<li>? 匹配前面子表达式0或1次</li>
<li>. 匹配处换行符之外的所以单字符</li>
<li>[ 标记一个中括号表达式开始</li>
<li>\ 转义符号</li>
<li>^ 匹配开头</li>
<li>{ 标记限定表达符开始 </li>
<li>| 两项之间选择一项</li>
</ul>
</li>
</ul>
<h1 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h1><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。</p>
<ul>
<li>* 0或者多次</li>
<li>+ 一次或者多次</li>
<li>?  0次或者1次</li>
<li>{n} 匹配n次</li>
<li>{n，} 至少匹配n次</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/12/08/js概览/">
                js概览
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-12-08</span>
            
            
            
                <span class="category">
                    <a href="/categories/前端/">前端</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><ul>
<li><p>JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到<code>&lt;head&gt;</code>中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    alert(<span class="string">'Hello, world'</span>);</div><div class="line">  &lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>第二种方法是把JavaScript代码放到一个单独的<code>.js</code>文件，然后在HTML中通过<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>引入这个文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"/static/js/abc.js"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ul>
<li><p>变量：<code>var x=1;</code></p>
</li>
<li><p>注释：同C语言</p>
</li>
<li><p>数据类型</p>
<ul>
<li>Number：所有数字</li>
<li>NaN:    NaN表示Not a Number，当无法计算结果时用NaN表示</li>
<li>Infinity: 表示无限大，当数值超过了JS的Number所能表示的最大值时，就表示为Infinity</li>
</ul>
</li>
<li><p>字符串：<code>&#39;abc&#39; 或者 &quot;abc&quot;</code></p>
</li>
<li><p>比较运算</p>
<ul>
<li><code>==</code>比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果</li>
<li><code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回<code>false</code>，如果一致，再比较。</li>
<li><strong><em>不要</em>使用<code>==</code>比较，始终坚持使用<code>===</code>比较。</strong></li>
<li><code>NaN</code>这个特殊的Number与所有其他值都不相等，包括它自己</li>
</ul>
</li>
<li><p>​ null &amp; undefined</p>
<ul>
<li><code>null</code>表示一个“空”的值，它和<code>0</code>以及空字符串<code>&#39;&#39;</code>不同，<code>0</code>是一个数值，<code>&#39;&#39;</code>表示长度为0的字符串，而<code>null</code>表示“空”。</li>
<li>用<code>null</code>表示一个空的值，而<code>undefined</code>表示值未定义。一般都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。</li>
</ul>
</li>
<li><p>数组 ：JavaScript的数组可以包括任意数据类型。</p>
<p>​           <code>var arr = [1, 2, 3.14, &#39;Hello&#39;, null, true];</code></p>
<p>​           <code>new Array(1, 2, 3); // 创建了数组[1, 2, 3]</code>  <strong>Array!!</strong></p>
<p>​          <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449921138898cdeb7fc2214dc08c6c67827758cd2f000" target="_blank" rel="external">具体操作方法</a></p>
<p>​</p>
<p>​</p>
</li>
<li><p>对象：JavaScript的对象是一组由键值对组成的无序集合，带有特殊字符的变量，需要用<code>&#39;&#39;</code>括起来。访问这个属性也无法使用<code>.</code>操作符，必须用<code>[&#39;xxx&#39;]</code>来访问：</p>
</li>
<li><p>​</p>
<pre><code>​<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line"><span class="attr">name</span>: <span class="string">'Bob'</span>,</div><div class="line"><span class="attr">age</span>: <span class="number">20</span>,</div><div class="line"><span class="attr">tags</span>: [<span class="string">'js'</span>, <span class="string">'web'</span>, <span class="string">'mobile'</span>],</div><div class="line"><span class="attr">city</span>: <span class="string">'Beijing'</span>,</div><div class="line"><span class="attr">hasCar</span>: <span class="literal">true</span>,</div><div class="line"><span class="attr">zipcode</span>: <span class="literal">null</span></div><div class="line">&#125;; <span class="comment">//变量名也可以用中文，但是，请不要给自己找麻烦。</span></div></pre></td></tr></table></figure>
</code></pre></li>
<li><p>strict模式：在strict模式下运行的JavaScript代码，强制通过<code>var</code>申明变量，未使用<code>var</code>申明变量就使用的，将导致运行错误。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div></pre></td></tr></table></figure>
<p> ​</p>
</li>
<li><p>多行字符串：最新的ES6标准新增了一种多行字符串的表示方法，用反引号 <em>`</em> … <em>`</em> 表示</p>
<p> ​</p>
</li>
<li><p>模板字符串：要把多个字符串连接起来，可以用<code>+</code>号连接</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'小明'</span>;</div><div class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</div><div class="line"><span class="keyword">var</span> message = <span class="string">`你好, <span class="subst">$&#123;name&#125;</span>, 你今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>;</div></pre></td></tr></table></figure>
<p> ​</p>
</li>
<li><p>循环</p>
<ul>
<li><p>for  同C语言</p>
</li>
<li><p><code>for ... in</code>循环，把一个对象的所有<strong>属性</strong>依次循环出来，<code>Array</code>也是对象，而它的每个元素的<strong>索引</strong>被视为对象的属性</p>
<pre><code>​<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;     <span class="comment">//i是索引</span></div><div class="line">    alert(i); <span class="comment">// '0', '1', '2'</span></div><div class="line">    alert(a[i]); <span class="comment">// 'A', 'B', 'C'</span></div><div class="line">&#125;</div><div class="line">    ​</div></pre></td></tr></table></figure>
</code></pre></li>
<li><p><code>for ... of</code> 只循环集合本身的元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">a.name = <span class="string">'Hello'</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123;</div><div class="line">    alert(x); <span class="comment">// 'A', 'B', 'C'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>while 同C语言</p>
</li>
</ul>
</li>
<li><p>map &amp; set </p>
<p> <code>Map</code>是一组键值对的结构，具有极快的查找速度。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'Michael'</span>, <span class="number">95</span>], [<span class="string">'Bob'</span>, <span class="number">75</span>], [<span class="string">'Tracy'</span>, <span class="number">85</span>]]);</div></pre></td></tr></table></figure>
<p>  一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉,<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345007434430758e3ac6e1b44b1865178e7aff9082e000" target="_blank" rel="external">详细讲解</a></p>
<p> <code>Set</code>和<code>Map</code>类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在<code>Set</code>中，没有重复的key</p>
</li>
<li><p>iterable</p>
<p> ​    ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。具有<code>iterable</code>类型的集合可以通过新的<code>for ... of</code>循环来遍历。</p>
<p> #函数</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func_name</span>(<span class="params">x</span>) </span></div><div class="line">&#123;</div><div class="line">    ...........</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> func_name = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span></div><div class="line">&#123;</div><div class="line">    ..........</div><div class="line">&#125;;<span class="comment">//匿名函数，末尾加;</span></div></pre></td></tr></table></figure>
<ul>
<li><p>关键字<code>arguments</code>，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。<code>arguments</code>类似<code>Array</code>但它不是一个<code>Array</code></p>
</li>
<li><p>rest参数</p>
<p>rest用于接受任意参数<code>function foo(a, b, ...rest);foo(1, 2, 3, 4, 5);</code>rest参数只能写在最后，前面用<code>...</code>标识</p>
</li>
</ul>
</li>
</ul>
<h1 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h1>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/11/17/关于ssd/">
                SSD科普
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-11-17</span>
            
            
            
                <span class="category">
                    <a href="/categories/sundry/">sundry</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="ssd结构"><a href="#ssd结构" class="headerlink" title="ssd结构"></a>ssd结构</h1><p>全称：Solid State Drive</p>
<ul>
<li><p>控制单元</p>
</li>
<li><p>存储单元(FLASH芯片、DRAM芯片)</p>
</li>
<li><p>缓存单元</p>
</li>
</ul>
<h2 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h2><h3 id="FLASH闪存"><a href="#FLASH闪存" class="headerlink" title="FLASH闪存"></a>FLASH闪存</h3><p>利用快闪（flash）浮栅MOS管</p>
<p>MOS管（浮栅）不同存储模式</p>
<ul>
<li><p>SLC（Single Level Cell） 快，贵，存储密度低，耐用</p>
<p>SLC的一个Flash存储单元（<strong>浮栅</strong>）只有两种电荷值，高低不同的电荷值表明0或者1，因为只需要一组高低电压就可以区分出0或者1信号，所以SLC最大的驱动电压可以做到很低。SLC结构简单，用一组变化电压驱动，速度很快，同时寿命较长也更为可靠，不过这种一个Block只存储一组数据的模式无法在相同的晶圆面积上实现较高的存储密度，存储容量提高完全依赖芯片工艺的提升。</p>
</li>
<li><p>MLC（Multi Levels Cell）  慢，便宜，存储密度高，不耐用</p>
<p>MLC在存储单元（<strong>浮栅</strong>）中实现多位存储能力，典型的是2bit。它通过<strong>不同级别的电压</strong>在一个单元中记录两组位信息（00、01、11、10），这样就可以将原本SLC的记录密度理论提升一倍。因为电压变化更频繁，所以MLC技术的Flash在寿命方面远劣于SLC，同时它的读写速度不如SLC，一个Block存储两组位数据，自然需要更长的时间，这里面还有电压控制、CRC写入方式等因素需要考虑。</p>
<ul>
<li><p>TLC （Trinary-Level Cell）</p>
<p>在1个存储器储存单元(浮栅)中存放3位元(bit)的资料</p>
</li>
</ul>
<p>​</p>
</li>
</ul>
<p>###DRAM</p>
<p>DRAM：Dynamic Random Access Memory   动态随机存取存储器</p>
<p>内存原理，少见</p>
<h2 id="寿命限制"><a href="#寿命限制" class="headerlink" title="寿命限制"></a>寿命限制</h2><p>反复写－擦，非常薄的栅氧化层（SiO2）的绝缘性就会降低（晶格结构被反复冲击之类的各种电效应热效应），漏电会越来越大，最后封不住电荷，也自然就读不出来不同状态－－所谓失效。 TLC在修改相同量数据时单个单元写－擦次数多，所以寿命短</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/09/29/php-part3-语句与数组/">
                php语句和数组
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-09-29</span>
            
            
            
                <span class="category">
                    <a href="/categories/php/">php</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="php语句和数组"><a href="#php语句和数组" class="headerlink" title="php语句和数组"></a>php语句和数组</h1><h2 id="php语句"><a href="#php语句" class="headerlink" title="php语句"></a>php语句</h2><ul>
<li><p>foreach</p>
<p>一般用于数组遍历，用法：</p>
<p><code>foreach(array_name as $value)</code>  或者</p>
<p><code>foreach(array_name as $key =&gt; $value)</code></p>
<p><code>$value</code>为数组元素的值，<code>$key</code>为数组下标。</p>
</li>
<li><p>exit</p>
<p>exit用于终止整个php程序的执行，exit之后的语句都不会被执行。用法：</p>
<p><code>exit(&quot;退出信息&quot;);</code></p>
</li>
</ul>
<hr>
<h2 id="php数组"><a href="#php数组" class="headerlink" title="php数组"></a>php数组</h2><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><ul>
<li><p><strong>数字索引数组</strong>：下标是数字</p>
</li>
<li><p><strong>关联数组</strong>：数组下标含有字符串（数字字符串混合也行）；<strong>如果下标为字符串，则要加上 ‘’ 或者””</strong></p>
</li>
</ul>
<p>###数组创建方式</p>
<ul>
<li><p>直接赋值法</p>
<p><code>$arr[key] =value</code><br><code>$arr[] = value</code><br>其中key为int或者字符串数据，value可以为任何值，包括数组类型（此时$arr为二维数组）</p>
</li>
<li><p>使用array()函数<br> ​     <code>$arr = array(&#39;key1&#39;=&gt;&#39;value1&#39;,&#39;kay2&#39;=&gt;&#39;value2&#39;...);</code>使用array()函数时，可以省略键名（key）。如果key省略，则默认以0开始。</p>
</li>
<li><p>创建二维数组</p>
<p> ​       <em>二维数组的元素本身是数组</em></p>
<ul>
<li><p>直接赋值法</p>
<p><code>$arr[0] = array(&#39;key1&#39;=&gt;&#39;value1&#39;...)</code></p>
<p><code>$arr[1] = array(&#39;key1&#39;=&gt;&#39;value1&#39;...)</code></p>
<ul>
<li>使用array()函数<br> `$str = array( <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">keys1 =&gt; <span class="keyword">array</span>(<span class="string">'key1'</span>=&gt;<span class="string">'value1'</span>...)</div><div class="line">keys2 =&gt;  <span class="keyword">array</span>(<span class="string">'key1'</span>=&gt;<span class="string">'value1'</span>...))`</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>###数组遍历与输出</p>
<ul>
<li><p>使用foreach（具体见前文）</p>
</li>
<li><p>使用list() 和 each()</p>
<p> <code>list($key,$value) =each($array)</code>，list()将数组中的值赋给一些变量，each()返回当前数组中指针所指的键名和对应值，<strong>并将指针移到下一位。</strong></p>
</li>
</ul>
<ul>
<li><p>print_r(mixed expression)</p>
<p>如果变量为非数组类型，则直接输出其本身，否则按键值对顺序显示数组</p>
<ul>
<li>var_dump()</li>
</ul>
<p>输出数组或对象，元素数量以及每个字符串长度。还能以缩进方式输出数组或对象的结构</p>
</li>
</ul>
<hr>
<h2 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h2><h3 id="1-创建函数"><a href="#1-创建函数" class="headerlink" title="1.创建函数"></a>1.创建函数</h3><ul>
<li><p><strong>range(int low, int high, int step(可选))</strong></p>
<p>low：数组元素最小值，high：数组元素最大值，step：数值进步数，默认为1</p>
</li>
<li><p><strong>array_combine( key_array, value_array)</strong></p>
<p>将两个元素个数相等的数组合并成一个数组，如果两个数组元素个数不等或者为空，返回false。key_array做索引，value_array做数组值。</p>
</li>
<li><p><strong>array_fill( int start_index, int num, mixed value)</strong></p>
<p>用同一个值填充数组。start_index：起始键名，num：填充数&gt;0，value：用来填充的值。</p>
</li>
<li><p><strong>array_pad( array input, int pad_size, pad_value)</strong></p>
<p>用指定值将数组填充到指定长度。input：输入数组，pad_size：填充长度，正数从左边开始填充，负数从右边开始，pad_value：填充值。</p>
</li>
<li><p><strong>explode(separator, string, int limit（可选）)</strong></p>
<p>按照指定规则对一串字符串进行分割，</p>
<p>​</p>
<p>​</p>
<p>​</p>
</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/09/29/php-part4-网页交互/">
                php网页交互
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-09-29</span>
            
            
            
                <span class="category">
                    <a href="/categories/php/">php</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="php网页交互"><a href="#php网页交互" class="headerlink" title="php网页交互"></a>php网页交互</h1><h2 id="GET-amp-POST方法获取数据"><a href="#GET-amp-POST方法获取数据" class="headerlink" title="GET &amp; POST方法获取数据"></a>GET &amp; POST方法获取数据</h2><ul>
<li><strong>GET方法</strong>是<form>表单默认方法，提交的信息附加于url提交到服务器；并且url数据大小 &lt; 1MB，否则会被截断。</form></li>
<li><strong>POST方法</strong>信息不附加于url；并且大小没有限制<h2 id="GET-amp-POST全局变量获取数据"><a href="#GET-amp-POST全局变量获取数据" class="headerlink" title="\$_GET &amp; $_POST全局变量获取数据"></a>\$_GET &amp; $_POST全局变量获取数据</h2></li>
</ul>
<p>\$_GET &amp; $_POST实际上是两个关联数组，//键名依次是”user”,”pwd”,”submit”</p>
<hr>
<h2 id="web表单"><a href="#web表单" class="headerlink" title="web表单"></a>web表单</h2><p>web表单主要用于将网页中的数据发送到服务器，实现交互。</p>
<p>表单结构如下</p>
<p><code>&lt;form name = &quot;&quot; method = &quot;&quot; action = &quot;&quot; enctype = &quot;&quot; target = &quot;&quot; id = &quot;&quot;&gt;</code></p>
<p>​       <code>表单元素</code></p>
<p> <code>&lt;/form&gt;</code></p>
<h3 id="表单属性："><a href="#表单属性：" class="headerlink" title="表单属性："></a>表单属性：</h3><ul>
<li><p>name：表单名称</p>
</li>
<li><p>method：提交方法（GET /  POST）</p>
</li>
<li><p>action：处理表单的页面的url（<strong>必须指定</strong>）</p>
</li>
<li><p>enctype：表单的编码方式（utf-8 …）</p>
</li>
<li><p>target：返回信息的<strong>显示方式</strong>，具体见下表</p>
</li>
<li><p>id：表单的id号</p>
</li>
</ul>
<p>target属性</p>
<ul>
<li><p>_blank      返回信息显示在新窗口</p>
</li>
<li><p>_parent     返回信息显示在父级窗口</p>
</li>
<li><p>_self           返回信息显示在当前窗口</p>
</li>
<li><p>_top            返回信息显示在顶级窗口</p>
</li>
</ul>
<hr>
<h3 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a><strong>表单元素</strong></h3><h4 id="文字域text"><a href="#文字域text" class="headerlink" title="文字域text"></a>文字域text</h4><p>用于向文本域中输入任何字符。</p>
<p> <code>&lt;input type = &quot;text&quot; name = &quot;&quot; maxlength = xxx size = xxx value = &quot;&quot;&gt;</code></p>
<ul>
<li>name：文字域名称</li>
<li>maxlength：最大输入长度</li>
<li>size：文字域宽度</li>
<li>value：文字域默认值（一般用于输出说明）</li>
</ul>
<h4 id="密码域password"><a href="#密码域password" class="headerlink" title="密码域password"></a>密码域password</h4><p> <code>&lt;input type = &quot;password&quot; name = &quot;&quot; maxlength = xxx size = xxx &gt;</code></p>
<ul>
<li>name：密码域名称</li>
<li>maxlength：最大密码长度</li>
<li>size：密码域宽度</li>
</ul>
<h4 id="单选按钮radio"><a href="#单选按钮radio" class="headerlink" title="单选按钮radio"></a>单选按钮radio</h4><p><code>&lt;input type = &quot;radio&quot; name = &quot;&quot; value = &quot;&quot; checked &gt;</code></p>
<ul>
<li>name：按钮名称</li>
<li>checked：表示此按钮默认选中</li>
<li>value：选中后传送到服务器的值</li>
</ul>
<h4 id="复选框checkbox"><a href="#复选框checkbox" class="headerlink" title="复选框checkbox"></a>复选框checkbox</h4><p><code>&lt;input type = &quot;checkbox&quot; name = &quot;&quot; value = &quot;&quot; checked &gt;</code></p>
<ul>
<li>name：复选框名称</li>
<li>checked：表示此按钮默认选中</li>
<li>value：选中后传送到服务器的值<h4 id="普通按钮button"><a href="#普通按钮button" class="headerlink" title="普通按钮button"></a>普通按钮button</h4></li>
</ul>
<p><code>&lt;input type = &quot;button&quot; name = &quot;&quot; value = &quot;&quot;&gt;</code></p>
<ul>
<li>name：普通按钮名称</li>
<li>value：显示在按钮上的文字<h4 id="提交按钮submit"><a href="#提交按钮submit" class="headerlink" title="提交按钮submit"></a>提交按钮submit</h4></li>
</ul>
<p><code>&lt;input type = &quot;submit&quot; name = &quot;&quot; value = &quot;&quot;&gt;</code></p>
<ul>
<li>name：提交按钮名称</li>
<li>value：显示在按钮上的文字</li>
</ul>
<h4 id="重置按钮reset"><a href="#重置按钮reset" class="headerlink" title="重置按钮reset"></a>重置按钮reset</h4><p>清楚表单已填内容，恢复默认</p>
<p><code>&lt;input type = &quot;reset&quot; name = &quot;&quot; value = &quot;&quot;&gt;</code></p>
<ul>
<li>name：重置按钮名称</li>
<li>value：显示在按钮上的文字</li>
</ul>
<h4 id="图像域image"><a href="#图像域image" class="headerlink" title="图像域image"></a>图像域image</h4><p>用图片代替按钮，使网页效果统一</p>
<p><code>&lt;input type = &quot;image&quot; name = &quot;&quot; src = &quot;url&quot;&gt;</code></p>
<ul>
<li>name：图像域名称</li>
<li>src：图片路径</li>
</ul>
<h4 id="隐藏域hidden"><a href="#隐藏域hidden" class="headerlink" title="隐藏域hidden"></a>隐藏域hidden</h4><p>在网页中对用户不可见。隐藏域用于向服务器收发数据，便于处理比如用户id，点提交时隐藏域一并提交到服务器。</p>
<p><code>&lt;input type = &quot;hidden&quot; name = &quot;&quot; value = &quot;&quot;&gt;</code></p>
<ul>
<li>name：隐藏域名称</li>
<li>value：选中后传送到服务器的值<h4 id="文件域file"><a href="#文件域file" class="headerlink" title="文件域file"></a>文件域file</h4></li>
</ul>
<p>用于传输文件，它可以查找硬盘中文件路径，并用表单将文件上传</p>
<p><code>&lt;input type = &quot;file&quot; name = &quot;file&quot; size = &quot;&quot; maxlength = &quot;&quot;&gt;</code></p>
<ul>
<li>name：文件域名称</li>
<li>size：文件域宽度</li>
<li>maxlength：输入的最大字符数</li>
</ul>
<h4 id="文本域标记textarea"><a href="#文本域标记textarea" class="headerlink" title="文本域标记textarea"></a>文本域标记textarea</h4><p>与text相比textarea可以添加多行文字，一般用于留言板。</p>
<p><code>&lt;textarea name = &quot;&quot; rows = xxx cols = xxx &gt; content &lt;/textarea&gt;</code></p>
<ul>
<li>name：文本域名称</li>
<li>rows：文本域行数</li>
<li>cols：文本域列数</li>
<li>content：文本域显示的类容</li>
</ul>
<h4 id="选择域-amp"><a href="#选择域-amp" class="headerlink" title="选择域\ &amp;\"></a>选择域\<select> &amp;\<option></option></select></h4><p>\<select>可以建一个下拉菜单，\<option>可以建立一个列表菜单。</option></select></p>
<p><code>&lt;select name = &quot;&quot; size = xxx multiple&gt;</code></p>
<p> <code>&lt;option value = &quot;&quot; selected&gt;选项1&lt;/option&gt;</code><br><code>&lt;option value = &quot;&quot; &gt;选项2&lt;/option&gt;</code><br><code>&lt;option value = &quot;&quot; &gt;选项3&lt;/option&gt;</code><br><code>...</code><br><code>&lt;/select&gt;</code></p>
<ul>
<li>name：选择域名称</li>
<li>size：列表行数</li>
<li>value：菜单选项值</li>
<li>multiple：表示以列表方式显示数据，省略则以菜单方式显示数据</li>
</ul>
<hr>
<h3 id="使用数组提交表单"><a href="#使用数组提交表单" class="headerlink" title="使用数组提交表单"></a>使用数组提交表单</h3><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="配置php-ini文件相关参数"><a href="#配置php-ini文件相关参数" class="headerlink" title="配置php.ini文件相关参数"></a>配置php.ini文件相关参数</h4><h4 id="全局变量-FILES"><a href="#全局变量-FILES" class="headerlink" title="全局变量$_FILES"></a>全局变量$_FILES</h4><p>$_FILES是一个数组包含了上传文件的信息</p>
<ul>
<li>$_FILES[file_name][name]   上传文件名</li>
<li>$_FILES[file_name][size]   文件大小</li>
<li>$_FILES[file_name][tmp_name]   临时目录中使用的文件名</li>
<li>$_FILES[file_name][type]   储存文件的MIME类型</li>
<li>$_FILES[file_name][error]   储存文件上传结果</li>
</ul>
<h4 id="文件上传函数"><a href="#文件上传函数" class="headerlink" title="文件上传函数"></a>文件上传函数</h4><ul>
<li><p>is_uploaded_file( filename )   判断文件是否是否是通过POST上传的</p>
</li>
<li><p>move_uploaded_file( filename, destination )  </p>
<p>filename：指定文件上传的临时名称（tmp_name）</p>
<p>destination：指定文件上传后的保存路径和新名称</p>
</li>
</ul>
<p>##服务器获取数据的其它方法</p>
<ul>
<li>$_REQUEST[]全局变量可以获取GET / POST / http cookie传递的数据，当不能确定用什么方法传递数据时可以用\$_REQUEST[]获取数据</li>
<li>$_SERVER[]全局变量包含服务器创建的信息</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/09/29/php-part5-函数&文件/">
                php函数&文件
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-09-29</span>
            
            
            
                <span class="category">
                    <a href="/categories/php/">php</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="php函数"><a href="#php函数" class="headerlink" title="php函数"></a>php函数</h1><p>分类：</p>
<ul>
<li><p>内置函数</p>
</li>
<li><p>自定义函数</p>
</li>
<li><p>变量函数</p>
</li>
</ul>
<p>##自定义函数</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><code>function func_name(参数1, 参数2,...可选参数1 = default1, 可选参数2 = default2,...)</code> 可选参数放在参数列表的最右端。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><p>按值传递 <code>func($var);</code></p>
</li>
<li><p>引用传递 <code>func(&amp;$var);</code></p>
</li>
</ul>
<p>###变量作用域</p>
<ul>
<li><p>全局变量：定义在函数外的变量</p>
</li>
<li><p>局部变量：定义在函数内部的变量</p>
</li>
<li><p>静态变量：用static声明的变量，同C语言</p>
<p><strong>要在函数内部引用全局变量，需要用global声明</strong></p>
</li>
</ul>
<hr>
<p>##变量函数</p>
<p>如果变量后面有括号，php将寻找与变量值相同函数并执行。</p>
<hr>
<p>#php文件</p>
<h2 id="include-amp-require"><a href="#include-amp-require" class="headerlink" title="include&amp;require"></a>include&amp;require</h2><p><code>include(&quot;file_name&quot;)</code><br><code>require(&quot;file_name&quot;)</code></p>
<p><strong>区别</strong><br>​        代码执行到include时，php将外部文件引用并读取文件内容。当文件执行错误时，php发出警告，并继续执行后面语句。</p>
<p>​        require，在php文件执行之前，php解释器先扫描文件，把所有引用文件读取重新合成新的php文件。</p>
<h2 id="include-once-amp-require-once"><a href="#include-once-amp-require-once" class="headerlink" title="include_once&amp;require_once"></a>include_once&amp;require_once</h2><p>作用同上，区别在于这两个语句会检查引用文件的唯一性，对所有文件只引用一次。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/09/29/php-part6-面向对象/">
                php面向对象
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-09-29</span>
            
            
            
                <span class="category">
                    <a href="/categories/php/">php</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>#php面向对象</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><strong>类（class）：</strong>属性和方法的集合。（可以简单理解为带有函数的结构体）</li>
<li><strong>对象：</strong>类的实例化。</li>
<li>三大特点：<strong>封装、继承、多态</strong>。<ul>
<li>封装：对类的使用和实现分离，用户只需要掌握接口。</li>
<li>继承：子类可以直接使用父类的属性和方法，简化了类操作，提高代码重用性。</li>
<li>多态：同一个类的不同对象，使用同一个方法可以得到不同的结果。提高代码重用性和程序的灵活性。。</li>
</ul>
</li>
</ul>
<hr>
<p>##类的操作</p>
<p>###声明</p>
<ul>
<li><p>定义类：<code>权限修饰符 class 类名{</code><br>​                               <code>类体;</code><br>​                                                       <code>}</code></p>
<ul>
<li>权限修饰符：<code>public  private  protected</code></li>
<li>成员属性：也称成员变量，用于记录类的属性信息。php中可以为标量类型和复合类型。不能为空类型和资源。</li>
<li>成员常量：<strong>关键字<code>const</code>。</strong>eg.<code>const PI = 3.14159</code>。常量的输出可以不需要类的实例化<code>类名::常量名</code>。</li>
<li>成员方法：也称成员函数，同一般函数。</li>
</ul>
<p>​</p>
</li>
</ul>
<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><ul>
<li><p>对象的创建：<code>$对象名 = new 类名([参数]);</code></p>
</li>
<li><p>类成员的访问：<code>$对象名-&gt;成员属性;</code><br>​                             <code>$对象名-&gt;成员方法();</code></p>
</li>
<li><p>$this操作符：表示对变量本身的引用eg. <code>\$this-&gt;属性; \$this-&gt;方法;</code>  <strong>属性名前没有\$</strong></p>
</li>
</ul>
<p>###构造&amp;析构</p>
<ul>
<li>​构造方法：对象创建成功后第一个被对象自动调用的方法。如果没有声明构造方法，系统会自动生成一个没有参数，且内容为空的构造方法,一个类只有一个构造方法。格式<code>function __construct();</code>         </li>
<li>析构方法：为创建对象的可选方法，一般是完成对象销毁前的清理工作。</li>
</ul>
<hr>
<p>##封装</p>
<h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><ul>
<li>public ：可以在程序的任何地点被其它类和对象调用，子类可以继承父类的公共成员。</li>
<li>private:只能在所属类的内部被调用和修改，外部类（即使子类）不能调用修改。</li>
<li>protected:只有本类和子类可以调用它，其它地方不行。</li>
</ul>
<h2 id="​-权限修饰符用于类定义前和成员声明前，如果省略权修饰符，默认为public"><a href="#​-权限修饰符用于类定义前和成员声明前，如果省略权修饰符，默认为public" class="headerlink" title="​           权限修饰符用于类定义前和成员声明前，如果省略权修饰符，默认为public"></a>​           <strong>权限修饰符用于类定义前和成员声明前，如果省略权修饰符，默认为public</strong></h2><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li><p>关键字extends：<code>class 子类名 extends 父类名 { 类体; }</code>子类可以拥有自己和父类的所有属性。</p>
</li>
<li><p>::操作符：<code>::</code>可以在没有声明任何实例的情况下访问类成员。</p>
<p>​                用法：<code>关键字 ::  变量/常量/方法;</code>其中关键字有如下三种：                         </p>
<ul>
<li>parent：调用父类成员</li>
<li>self：调用自身成员</li>
<li>类名：调用此类的成员</li>
</ul>
</li>
<li><p>覆盖父类方法：在子类中对父类的同名方法进行重写，<strong>此方法必须和父类方法有相同的名称，参数，返回值。</strong></p>
</li>
<li><p>关键字static：用于修饰成员变量和成员函数。静态变量和静态函数可以不用对象而使用类名直接访问。<strong>静态变量</strong>相当于储存在类中的全局变量用法<code>类名 ::$静态变量</code>，静态成员可以在对象被销毁后继续保留，方便下一次调用；<strong>静态函数</strong>只能使用静态变量，<code>类名:: 静态函数(...);</code></p>
<p>​                                </p>
</li>
</ul>
<hr>
<h2 id="抽象类-amp-接口"><a href="#抽象类-amp-接口" class="headerlink" title="抽象类&amp;接口"></a>抽象类&amp;接口</h2><p>抽象类和接口是不能被实例化的特殊类。</p>
<p>###抽象类</p>
<p>抽象类是不能被实例化的特殊类，只能作为其它类的父类使用。用法</p>
<p><code>abstract class 类名{</code></p>
<p><code>//抽象成员变量...</code></p>
<p><code>abstract function func1();</code></p>
<p><code>abstract function func2();</code></p>
<p>​                                     <code>}</code></p>
<p>抽象类至少包含一个抽象函数；抽象函数没有函数体，只有声明（末尾加分号）其功能在子类中实现；</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>php只支持单继承，要实现多重继承需要用到接口。</p>
<ul>
<li>声明</li>
</ul>
<p><code>interface 接口名{</code></p>
<p><code>//成员常量</code></p>
<p><code>//抽象函数}</code></p>
<p>接口中不能声明变量，只能是成员常量和抽象函数<strong>所有的函数都必须在子类中实现，否则报错</strong>，接口的权限只能为public。</p>
<ul>
<li><p>用法</p>
<p><code>class 类名 implement 接口1,接口2...{//抽象函数实现}</code></p>
</li>
</ul>
<hr>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li><p>通过重写父类函数实现</p>
</li>
<li><p>通过写不同的接口抽象函数实现</p>
</li>
</ul>
<p>##其它关键字&amp;魔术方法</p>
<ul>
<li>final：用于修饰类或成员函数，修饰类表示此类为最终版本，不可再有子类；修饰成员函数表示此函数不可被重写覆盖。</li>
<li>clone：用于对象克隆，<code>$对象名 = clone $原对象名;</code></li>
<li>instanceof：用于检验某对象是否属于某个类<code>obj_name instanceof class_name</code></li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/09/29/查询系统&爬虫实践小结/">
                查询系统&爬虫实践小结
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-09-29</span>
            
            
            
                <span class="category">
                    <a href="/categories/web/">web</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="web后端实践小结"><a href="#web后端实践小结" class="headerlink" title="web后端实践小结"></a>web后端实践小结</h1><h2 id="成绩查询系统"><a href="#成绩查询系统" class="headerlink" title="成绩查询系统"></a>成绩查询系统</h2><p>​                   <strong>合作开发，先 git pull，再开始工作</strong></p>
<h3 id="PDO-PHP数据库对象的使用"><a href="#PDO-PHP数据库对象的使用" class="headerlink" title="PDO-PHP数据库对象的使用"></a>PDO-PHP数据库对象的使用</h3><p>连接</p>
<hr>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$conn = <span class="keyword">new</span> PDO(<span class="string">'mysql:host=xxx;dbname=xxx'</span>, $user, $pass)` PDOl连接</div><div class="line"></div><div class="line">$conn = <span class="keyword">new</span> PDO(<span class="string">'mysql:host=xxx;dbname=xxx'</span>, $user,       $pass,<span class="keyword">array</span>(PDO::ATTR-PERSISTENT =&gt; <span class="keyword">true</span>)) PDO持久连接</div><div class="line"></div><div class="line">$conn = <span class="keyword">null</span>` PDO连接关闭</div></pre></td></tr></table></figure>
<p>​    <strong>dsn：data source name（数据源） 包括 主机、库名、驱动名</strong><br>​     <em>部分参数可以省略,参数没有顺序</em><br>​    <em>mysql: 最短 会自动调取 php.in 中 mysql.default_host 参数信息</em></p>
<p>预处理语句</p>
<hr>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$stmt = $conn-&gt;prepare(<span class="string">"INSERT INTO REGISTRY (name, value) VALUES (:name, :value)"</span>);</div><div class="line">$stmt-&gt;bindParam(<span class="string">':name'</span>, $name);</div><div class="line">$stmt-&gt;bindParam(<span class="string">':value'</span>, $value);</div><div class="line"></div><div class="line"><span class="comment">// 插入一行</span></div><div class="line">$name = <span class="string">'one'</span>;</div><div class="line">$value = <span class="number">1</span>;</div><div class="line">$stmt-&gt;execute();</div><div class="line"></div><div class="line"><span class="comment">// 用不同的值插入另一行</span></div><div class="line">$name = <span class="string">'two'</span>;</div><div class="line">$value = <span class="number">2</span>;</div><div class="line">$stmt-&gt;execute();</div></pre></td></tr></table></figure>
<p>$conn-&gt;prepare( ) 预处理语句<br>$stmt-&gt;bindParam 填充参数<br>$stmt-&gt;execute(); 执行语句</p>
<p>###验证码生产</p>
<p>利用php GD库<br> <a href="https://github.com/php-login-system/php-demo/blob/master/identify/img.php" target="_blank" rel="external">示例代码</a></p>
<h3 id="邮件发送-phpmailer"><a href="#邮件发送-phpmailer" class="headerlink" title="邮件发送-phpmailer"></a>邮件发送-phpmailer</h3><p><a href="http://blog.csdn.net/ljl890705/article/details/50345211" target="_blank" rel="external">使用说明</a><br><a href="https://github.com/PHPMailer/PHPMailer" target="_blank" rel="external">github地址</a></p>
<h2 id="豆瓣爬虫"><a href="#豆瓣爬虫" class="headerlink" title="豆瓣爬虫"></a>豆瓣爬虫</h2><h3 id="内容获取–curl"><a href="#内容获取–curl" class="headerlink" title="内容获取–curl"></a>内容获取–curl</h3><p><strong>cURL</strong>是一个利用URL语法在<a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2" target="_blank" rel="external">命令行</a>下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ch = curl_init(); <span class="comment">//初始化 cURL 会话 $ch curl句柄</span></div><div class="line">    curl_setopt($ch, CURLOPT_URL, $url);  <span class="comment">// 设置要抓取的页面地址</span></div><div class="line">    curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>); <span class="comment">// 抓取结果直接返回（如果为0，则直接输出内容到页面）</span></div><div class="line">    <span class="comment">//关闭SSL证书验证</span></div><div class="line">    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, <span class="keyword">false</span>);</div><div class="line">    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, <span class="keyword">false</span>);</div><div class="line">    $res = curl_exec($ch);   <span class="comment">//返回html字符串</span></div><div class="line">    curl_close($ch);   <span class="comment">//关闭 cURL 会话</span></div></pre></td></tr></table></figure>
<h3 id="HTML解析–simple-html-dom"><a href="#HTML解析–simple-html-dom" class="headerlink" title="HTML解析–simple-html-dom"></a>HTML解析–simple-html-dom</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取网页内容</span></div><div class="line">        $html = get_html($url);</div><div class="line">        $douban = <span class="keyword">new</span> simple_html_dom(); <span class="comment">//创建simple_html_dom对象douban</span></div><div class="line">        $douban-&gt;load($html);</div><div class="line">        <span class="comment">//提取电影名</span></div><div class="line">        $names = $douban-&gt;find(<span class="string">'span.title,span.other'</span>);</div></pre></td></tr></table></figure>
<p>  主要熟悉html树</p>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="disabled" href="/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/2/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2017/12/15/关于系统底层/关于系统底层/">关于系统底层的杂烩</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2017/12/09/HttpNote/">HttpStudy</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2017/12/08/reg_exp待续/">reg_exp</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2017/12/08/js概览/">js概览</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/categories/mysql/">mysql</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/etc/">etc</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/ladder/">ladder</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/hexo/">hexo</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/matthew-sword">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:lucklgh@126.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>